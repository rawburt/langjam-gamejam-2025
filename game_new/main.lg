use std
use textures
use sprites
use items
use obstacles
use camera
use map
use text

rec Modal do
  lines: [str]
end

enum GameState do
  Play
  Win
  Dead
end

enum Scene do
  Game
  Inventory
  Modal
end

rec World do
  player: Player
  camera: Camera
  map: Map
  modal: Modal
  game_state: GameState
  scene: Scene
end

def world_init() World do
  var map: Map = map_init()

  var player: Player = player_init()
  player.pos = map.start

  var camera: Camera = Camera(pos: Vec2(x: 0, y: 0))
  camera_update(camera, player)

  var world: World = World(
    player: player,
    camera: camera,
    map: map,
    modal: Modal(lines: []),
    game_state: GameState.Play,
    scene: Scene.Game
  )

  ret world
end

var world: World = world_init()

--------------------------------------------------------------

def try_move(world: World, move: Key) do
  var change: Vec2 = Vec2(x: 0, y: 0)

  --- `cond` because we don't care about some Key's
  cond do
    when move == Key.Left do
      change.x -= 1
    end
    when move == Key.Right do
      change.x += 1
    end
    when move == Key.Up do
      change.y -= 1
    end
    when move == Key.Down do
      change.y += 1
    end
  end

  var pos: Vec2 = Vec2(
    x: world.player.pos.x + change.x,
    y: world.player.pos.y + change.y
  )

  var can_move: bool = true

  --- is there an obstacle to interact with
  for obstacle in world.map.obstacles do
    if obstacle.pos == pos && obstacle.active do
      can_move = false
      --- open obstacle modal
      var modal: Modal = Modal(lines: obstacle.info)
      world.modal = modal
      world.scene = Scene.Modal
      break
    end
  end

  --- is there an item to pick up

  --- is it a walkable map tile
  if can_move do
    if map_location_walkable(world.map, pos) do
      world.player.pos = pos
    end
  end
end

--------------------------------------------------------------[ SCENE: Game ]

def game_update(world: World) do
  cond do
    when buttonp(Key.Left) do
      try_move(world, Key.Left)
    end
    when buttonp(Key.Right) do
      try_move(world, Key.Right)
    end
    when buttonp(Key.Up) do
      try_move(world, Key.Up)
    end
    when buttonp(Key.Down) do
      try_move(world, Key.Down)
    end
  end

  camera_update(world.camera, world.player)

  if buttonp(Key.X) do
    world.scene = Scene.Inventory
  end
end

def game_draw(world: World) do
  clear()
  map_draw(world.map, world.camera)
  player_draw(world.player)
end

--------------------------------------------------------------[ SCENE: Inventory ]

def inventory_update() do
  if buttonp(Key.X) do
    world.scene = Scene.Game
  end
end

def inventory_draw(inventory: Inventory) do
  clear()
  render_text_centered("INVENTORY", 0)
  if len(inventory.items) == 0 do
    render_text_centered("EMPTY", 6)
  else
    for i = 0 to len(inventory.items) do
      var item: Item = inventory.items[i]
      render_sprite(item.sprite, 0, (TILE_SIZE*2) + (i * TILE_SIZE))
      render_text(item.info, 2, 2 + i)
    end
  end
end

--------------------------------------------------------------[ SCENE: Modal ]

def modal_update() do
  if buttonp(Key.X) do
    world.scene = Scene.Game
  end
end

def modal_draw(modal: Modal) do
  clear()
  for i = 0 to len(modal.lines) do
    render_text_centered(modal.lines[i], i)
  end
end

--------------------------------------------------------------[ main game loop ]

def update() do
  match world.scene do
    when Scene.Game do
      game_update(world)
    end
    when Scene.Inventory do
      inventory_update()
    end
    when Scene.Modal do
      modal_update()
    end
  end
end

def draw() do
  match world.scene do
    when Scene.Game do
      game_draw(world)
    end
    when Scene.Inventory do
      inventory_draw(world.player.inventory)
    end
    when Scene.Modal do
      modal_draw(world.modal)
    end
  end
end
