use std
use textures
use sprites
use items
use obstacles
use camera
use map
use text
use scenes

rec Modal do
  lines: [str]
  sprites: [Sprite]
end

enum GameState do
  Play
  Win
  Dead
end

rec World do
  player: Player
  camera: Camera
  map: Map
  modal: Modal
  game_state: GameState
  scene: Scene
end

def world_init() World do
  var map: Map = map_init()

  var player: Player = player_init()
  player.pos = map.start

  var camera: Camera = Camera(pos: Vec2(x: 0, y: 0))
  camera_update(camera, player)

  var world: World = World(
    player: player,
    camera: camera,
    map: map,
    modal: Modal(lines: [], sprites: []),
    game_state: GameState.Play,
    scene: Scene.Game
  )

  ret world
end

var world: World = world_init()

-------------------------------------------------------------- [ big important move logic ]

def try_move(world: World, move: Key) do
  var change: Vec2 = Vec2(x: 0, y: 0)

  --- `cond` because we don't care about some Key's
  cond do
    when move == Key.Left do
      change.x -= 1
    end
    when move == Key.Right do
      change.x += 1
    end
    when move == Key.Up do
      change.y -= 1
    end
    when move == Key.Down do
      change.y += 1
    end
  end

  var pos: Vec2 = Vec2(
    x: world.player.pos.x + change.x,
    y: world.player.pos.y + change.y
  )

  var can_move: bool = true

  --- is there an obstacle to interact with
  for i = 0 to len(world.map.obstacles) do
    var obstacle: Obstacle = world.map.obstacles[i]

    if obstacle.active && obstacle.pos == pos do
      --- does player meet requirements to solve obstacle
      if obstacle_requirements_met(obstacle, world.player) do
        delete(i, world.map.obstacles)
        break
      end

      --- obstacle is in the way
      can_move = false

      --- open obstacle modal
      var modal: Modal = Modal(
        lines: obstacle.info,
        sprites: obstacle.info_sprites
      )
      world.modal = modal
      world.scene = Scene.Modal
      break
    end
  end

  --- is there an item to pick up
  if can_move do
    for item in world.map.items do
      if item.active && item.pos == pos do
        --- pick up item
        player_add_item_to_inventory(world.player, item)

        --- TODO: better way to remove items from map
        item.active = false

        --- tell the player about the item
        var modal: Modal = Modal(
          lines: ["","PICKED UP:", "", item.info],
          sprites: [item.sprite]
        )
        world.modal = modal
        world.scene = Scene.Modal
        break
      end
    end
  end

  --- is it a walkable map tile
  if can_move do
    if map_location_walkable(world.map, pos) do
      world.player.pos = pos
    end
  end
end

--------------------------------------------------------------[ SCENE: Game ]

def game_update(world: World) do
  cond do
    when buttonp(Key.Left) do
      try_move(world, Key.Left)
    end
    when buttonp(Key.Right) do
      try_move(world, Key.Right)
    end
    when buttonp(Key.Up) do
      try_move(world, Key.Up)
    end
    when buttonp(Key.Down) do
      try_move(world, Key.Down)
    end
  end

  camera_update(world.camera, world.player)

  if buttonp(Key.Z) do
    world.scene = Scene.Inventory
  end
end

def game_draw(world: World) do
  clear()
  map_draw(world.map, world.camera)
  player_draw(world.player)
end

--------------------------------------------------------------[ SCENE: Inventory ]

def inventory_update() do
  if buttonp(Key.X) do
    world.scene = Scene.Game
  end
end

def inventory_draw(inventory: Inventory) do
  clear()
  render_text_centered("INVENTORY", 1)
  if len(inventory.items) == 0 do
    render_text_centered("EMPTY", 6)
  else
    for i = 0 to len(inventory.items) do
      var item: Item = inventory.items[i]
      render_sprite(item.sprite, 0, (TILE_SIZE*3) + (i * TILE_SIZE))
      render_text(item.info, 2, 3 + i)
    end
  end
end

--------------------------------------------------------------[ SCENE: Modal ]

def modal_update() do
  if buttonp(Key.X) do
    world.scene = Scene.Game
  end
end

def modal_draw(modal: Modal) do
  clear()
  var i: int = 0
  for l in modal.lines do
    render_text_centered(l, i)
    i += 1
  end
  var sprites_len: int = len(modal.sprites)
  var start_x: int = (16 - sprites_len) / 2
  for s = 0 to sprites_len do
    render_sprite(modal.sprites[s], (start_x * TILE_SIZE) + (s * TILE_SIZE), (i + 1) * TILE_SIZE)
  end
end

--------------------------------------------------------------[ SCENE: MapChange ]

def map_change_draw(world: World) do
  clear()
  cond do
    when world.map.id == 1 do
      render_text_centered("VOID AWAKENS", 2)
      render_text_centered("VOID PULLS YOU", 5)
    end
  end
end

def map_change_update(world: World) do
  if buttonp(Key.Z) || buttonp(Key.X) do
    var next_map: int = map_next(world.map.id)
    if next_map == NO_MAP do
      --- game over
    else
      world.map = map_get(next_map)
      world.player.pos = world.map.start
      camera_update(world.camera, world.player)
      world.scene = Scene.Game
    end
  end
end

--------------------------------------------------------------[ main game loop ]

world.scene = Scene.MapChange

def update() do
  --- fancy event system
  if events_exist() do
    var event: Event = events_pop()
    match event.kind do
      when EventKind.None do
        --- nothing
      end
      when EventKind.ChangeScene do
        world.scene = event.scene
      end
    end
  end

  --- scene specific updates
  match world.scene do
    when Scene.Game do
      game_update(world)
    end
    when Scene.Inventory do
      inventory_update()
    end
    when Scene.Modal do
      modal_update()
    end
    when Scene.MapChange do
      map_change_update(world)
    end
  end
end

def draw() do
  --- scene specific draws
  match world.scene do
    when Scene.Game do
      game_draw(world)
    end
    when Scene.Inventory do
      inventory_draw(world.player.inventory)
    end
    when Scene.Modal do
      modal_draw(world.modal)
    end
    when Scene.MapChange do
      map_change_draw(world)
    end
  end
end
