use std
use sprites
use text
use map
use items
use player

enum Scene do
  Main
  Inventory
end

var scene: Scene = Scene.Main

------------------------------ [ SCENE: Main ]

def update_player() do
  --- player movement
  if buttonp(Key.Left) && can_walk(player.pos.x - 1, player.pos.y) do
    player.pos.x -= 1
  end
  if buttonp(Key.Right) && can_walk(player.pos.x + 1, player.pos.y) do
    player.pos.x += 1
  end
  if buttonp(Key.Up) && can_walk(player.pos.x, player.pos.y - 1) do
    player.pos.y -= 1
  end
  if buttonp(Key.Down) && can_walk(player.pos.x, player.pos.y + 1) do
    player.pos.y += 1
  end
  --- scene selection
  if buttonp(Key.X) do
    scene = Scene.Inventory
  end

  --- pick up items
  for item in items do
    if !item.picked_up do
      if item.pos == player.pos do
        push(item, player.inventory)
        item.picked_up = true
      end
    end
  end
end

def update_camera() do
  camera.x = player.pos.x - 8
  camera.y = player.pos.y - 8
end
--- update camera before game starts
update_camera()

def draw_player() do
  render_tile(player.sprite, 8, 8)
end

def update_main() do
  update_player()
  update_camera()
end

def draw_main() do
  draw_map()
  draw_player()
  draw_items()
end

------------------------------ [ SCENE: Inventory ]

def update_inventory() do
  if buttonp(Key.X) do
    scene = Scene.Main
  end
end

def draw_inventory() do
  render_text("INVENTORY", 3, 0)
  if len(player.inventory) == 0 do
    render_text("EMPTY", 5, 6)
  else
    for i = 0 to len(player.inventory) do
      var item: Item = player.inventory[i]
      render_sprite(item.sprite, 0, (TILE_SIZE*2) + (i * TILE_SIZE))
      render_text(item.detail, 2, 2 + i)
    end
  end
end

------------------------------ [ game loop]

def update() do
  match scene do
    when Scene.Main do
      update_main()
    end
    when Scene.Inventory do
      update_inventory()
    end
  end
end

def draw() do
  clear()
  match scene do
    when Scene.Main do
      draw_main()
    end
    when Scene.Inventory do
      draw_inventory()
    end
  end
end
