use std
use sprites
use items
use obstacles
use camera
use map1
use map2

rec Map do
  id: int
  w: int
  h: int
  data: [int]
  start: Vec2
  items: [Item]
  obstacles: [Obstacle]
end

var maps: [Map] = []

def map1_init() Map do
  var map: Map = Map(
    id: 1,
    w: MAP1_WIDTH,
    h: MAP1_HEIGHT,
    data: MAP1_DATA,
    start: MAP1_START_POS,
    items: map1_items_init(),
    obstacles: map1_obstacles_init()
  )
  ret map
end

def map2_init() Map do
  var map: Map = Map(
    id: 2,
    w: MAP2_WIDTH,
    h: MAP2_HEIGHT,
    data: MAP2_DATA,
    start: MAP2_START_POS,
    items: map2_items_init(),
    obstacles: map2_obstacles_init()
  )
  ret map
end

def maps_init() do
  maps = []
  push(map1_init(), maps)
  push(map2_init(), maps)
end

def map_init() Map do
  maps_init()
  ret maps[0]
end

const NO_MAP: int = -1

def map_next(id: int) int do
  var next: int = id
  if next < len(maps) do
    ret next
  end
  ret NO_MAP
end

def map_get(id: int) Map do
  ret maps[id]
end

def render_map_tile(tile: int, x: int, y: int) do
  var sprite: Sprite = map_sprite(tile)
  render_tile(sprite, x, y)
end

def map_draw(map: Map, camera: Camera) do
  for y = 0 to 16 do
    for x = 0 to 16 do
      var map_x: int = x + camera.pos.x
      var map_y: int = y + camera.pos.y
      if map_x >= 0 && map_y >= 0 && map_x < map.w && map_y < map.h do
        var tile: int = map.data[map_y * map.w + map_x]
        if tile != 0 do
          render_map_tile(tile, x, y)
        end
      end
    end
  end

  for obstacle in map.obstacles do
    if obstacle.active do
      if camera_in_view(camera, obstacle.pos) do
        var screen_x: int = obstacle.pos.x - camera.pos.x
        var screen_y: int = obstacle.pos.y - camera.pos.y
        render_tile(obstacle.sprite, screen_x, screen_y)
      end
    end
  end

  for item in map.items do
    if item.active do
      if camera_in_view(camera, item.pos) do
        var screen_x: int = item.pos.x - camera.pos.x
        var screen_y: int = item.pos.y - camera.pos.y
        render_tile(item.sprite, screen_x, screen_y)
      end
    end
  end
end

def map_get_tile(map: Map, x: int, y: int) int do
  ret map.data[(y * map.w) + x]
end

def map_location_walkable(map: Map, pos: Vec2) bool do
  var walkable: bool = false
  var tile: int = map_get_tile(map, pos.x, pos.y)
  for walkable_tile in WALKABLE_TILES do
    if tile == walkable_tile do
      walkable = true
      break
    end
  end
  ret walkable
end
